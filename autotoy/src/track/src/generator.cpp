#include "ros/ros.h"
#include "track/Generator.h"
#include "track/ConePlacer.h"
#include "track/Track.h"
// to use a client node within a server node go to https://answers.ros.org/question/197868/can-a-node-be-a-subscriber-and-client-at-the-same-time/


// Declare some variables that need to be defined before generateTrack is defined
bool generateTrack(track::Generator::Request  &req, track::Generator::Response &res);
ros::ServiceClient *clientPtr; //pointer for a client



int main(int argc, char **argv)
{
  // Initialize ROS; name of the node: "generator"
  ros::init(argc, argv, "generator");
  ros::NodeHandle n;

  // ros::ServiceClient client = n.serviceClient<PACKAGE_NAME::SERVICE_NAME>("SERVICE_NAME");
  // create client needed to request from cones
  ros::ServiceClient client = n.serviceClient<track::ConePlacer>("/track/ConePlacer"); 
  clientPtr = &client; //give the address of the client to the clientPtr

  // Here the service is created and advertised over ROS. 
  ros::ServiceServer service = n.advertiseService("/track/Generator", generateTrack);

  ROS_INFO("Ready to generate tracks.");

  /*
  when you do have a subscriber, all of your code runs then you put a spin() at the end 
  to keep the program from just exiting when it reaches the end of main(). 
  Instead of exiting, a loop continuously runs to allow the callbacks to be called when a new message arrives. 
  To be clear, ROS will not process any callback until spin() is called. 
  */
  ros::spin();

  return 0;
}


// This function provides the service for generating the track, 
// it takes in the request and response type defined in the srv file and returns a boolean. 
bool generateTrack(track::Generator::Request  &req,
         track::Generator::Response &res)
{
  // create centreline
  int numberofpoints = 5;
  std::vector<track::Point> my_array(numberofpoints);
  for(int i = 0; i < numberofpoints; i++)
  {
    my_array[i].x = (float)(i*1+3);
    my_array[i].y = (float)(i*2+4);
  }

  std::vector<track::Point> centrelinepoints = my_array;
  track::Line* centreline = new track::Line();
  //  a->b is essentially a shorthand notation for (*a).b, 
  // ie, if a is a pointer to an object, then a->b is accessing the property b of the object that points to.
  centreline->points = centrelinepoints;

  //set up client made in main and request data from ConePlacer
  ros::ServiceClient client = (ros::ServiceClient)*clientPtr; //dereference the clientPtr

  // Here we instantiate an autogenerated service class, and assign values into its request member. 
  track::ConePlacer srv;
  srv.request.centreline = *centreline;

  /*
  This actually calls the service. Since service calls are blocking, it will return once the call is done. 
  If the service call succeeded, call() will return true and the value in srv.response will be valid. 
  If the call did not succeed, call() will return false and the value in srv.response will be invalid. 
  */
  if (client.call(srv))
  {
    ROS_INFO("requested cones from centreline generator");
  }
  else
  {
    ROS_ERROR("Failed to call service from coneplacer");
  }


  //create and fill node response object (track)
  track::Track* output = new track::Track();
  output->centreline = *(centreline);
  output->leftcones = srv.response.leftcones;
  output->rightcones = srv.response.rightcones;
  res.track = *output;
  ROS_INFO("Generated new track in response to generator-request");
  return true;
}
